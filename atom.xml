<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ganxinming.github.io</id>
    <title>Joke</title>
    <updated>2019-06-12T14:24:24.771Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ganxinming.github.io"/>
    <link rel="self" href="https://ganxinming.github.io/atom.xml"/>
    <subtitle>那些杀不死你的，必将使你变得更加怪异。</subtitle>
    <logo>https://ganxinming.github.io/images/avatar.png</logo>
    <icon>https://ganxinming.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Joke</rights>
    <entry>
        <title type="html"><![CDATA[Executor家族]]></title>
        <id>https://ganxinming.github.io/post/executor-jia-zu</id>
        <link href="https://ganxinming.github.io/post/executor-jia-zu">
        </link>
        <updated>2019-06-12T07:51:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="executor">Executor</h2>
<p>Executor：执行器是一个接口，只有一个方法execute执行任务，在java的线程池的框架里边，这个是最顶层的接口；
Executors ：操作Executor的一个工具类，用于创建线程池。
ExecutorService：从Executor接口继承,可以管理线程池。是他的Executors.newFixedThreadPool(2);返回值。<br>
Callable：是一个接口，类似于Runnable接口。实现该接口需重写call方法。<strong>该方法有返回值</strong>。
Future ：是线程池提交处理callable后，产生的返回值。</p>
<h4 id="四种线程池">四种线程池</h4>
<p>种线程池区别：</p>
<ul>
<li>1.newFixedThreadPool ：产生指定的线程，比如4个，那么一次只能运行4个线程，后来的必须排队，等到线程有空闲才能进行。</li>
<li>2.newCachedThreadPool ：可以重用之前已构造的可用线程（就是上一个可以用的线程），如果不存在可用线程，那么会重新创建一个新的线程并将其加入到线程池中</li>
<li>3.newSingleThreadExecutor ：产生单个线程，只能处理一个线程</li>
<li>4.newScheduledThreadPool  ：执行定时的任务，定时器线程池</li>
</ul>
<h2 id="四种线程创建的方法如下">四种线程创建的方法如下：</h2>
<pre><code>package basis.ThreadTest.simple;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.concurrent.*;

/**
 * @Author Badribbit
 * @create 2019/6/8 20:04
 * @Define 创建线程的四种方式
 * @Tutorials
 * @Opinion:
 *
 * 对于实现Callable接口通过FutureTask包装器来创建Thread线程
 * 1.实现Callable接口2.创建FutureTask（他实现了runnable）3.实例化化Thread
 * 对于使用ExecutorService、Callable、Future实现有返回结果的线程
 * 1.实现Callable接口2.通过在main方法中的线程池的submit方法执行。3.得到future对象（返回的对象）
 * 重要：1.Runnable接口，需要实例化Thread才能调用start方法。
 *      2.线程池两种执行线程方法,execute()和submit().
 *      execute()主要针对的Runnable的类，他没有返回值
 *      submit() 主要针对的Callable的类，他有返回值，且返回值用future定义。
 *      3.future通过get()获得返回值。
 */
public class SimpleTest1 {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //Thread 方式实现
        St1 s1=new St1();
        s1.start();
        //Runnable 方式实现
        St2 s2=new St2();
        Thread ts2=new Thread(s2);
        ts2.start();
        //实现Callable接口通过FutureTask包装器来创建Thread线程
        //由Callable&lt;Integer&gt;创建一个FutureTask&lt;Integer&gt;对象：
        Callable callable=new SomeCallable();
        //注释：FutureTask&lt;Integer&gt;是一个包装器，它通过接受Callable&lt;Integer&gt;来创建，它同时实现了Future和Runnable接口
        FutureTask futureTask=new FutureTask(callable);
        Thread s3=new Thread(futureTask);
        s3.start();
        //使用ExecutorService、Callable、Future实现有返回结果的线程
        //创建一个线程池,返回一个ExecutorService。
        ExecutorService pool= Executors.newFixedThreadPool(4);
        //Future就是Callable的call方法返回的封装了结果的对象
        List&lt;Future&gt; list=new ArrayList&lt;Future&gt;();
        for (int i=0;i&lt;9;i++){
            Callable callable1=new OtherCallable(&quot;&quot;+i);
            //submit提交Callable，执行并有返回值,用future接受
            Future future=pool.submit(callable1);
            list.add(future);
        }
        //关闭线程池
        pool.shutdown();
        // 获取所有并发任务的运行结果
       for (int i=0;i&lt;9;i++){
           Future future=list.get(i);
           //future通过get方法，取返回的对象。
           System.out.println(future.get().toString());
       }
    }
}

class St1 extends Thread{
    @Override
    public void run() {
        super.run();
        System.out.println(&quot;通过继承Thread方式运行&quot;);
    }
}

/**
 * 因为Runnable没有start方法，需要Thread ts2=new Thread(s2);将它变成Thread类。
 */
class St2 implements Runnable{
    @Override
    public void run() {
        System.out.println(&quot;通过实现Runnable接口&quot;);
    }
}

/**
 * 实现Callable接口通过FutureTask包装器来创建Thread线程
 * @param
 */
class SomeCallable implements Callable{

    @Override
    public Object call() throws Exception {
        System.out.println(&quot;实现Callable接口通过FutureTask包装器来创建Thread线程&quot;);
        return null;
    }
}

/**
 * 使用ExecutorService、Callable、Future实现有返回结果的线程
 */
class OtherCallable implements Callable{
    private String name;
    public OtherCallable(String name){
        this.name=name;
    }
    @Override
    public Object call() throws Exception {
        Date date=new Date();
        System.out.println(&quot;线程名&quot;+name);
        System.out.println(&quot;开始运行时间&quot;+date.toString());
        return  date;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Concurrent并发包下的类]]></title>
        <id>https://ganxinming.github.io/post/concurrent-bing-fa-bao-xia-de-lei</id>
        <link href="https://ganxinming.github.io/post/concurrent-bing-fa-bao-xia-de-lei">
        </link>
        <updated>2019-06-11T01:38:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="实现并发1阻塞式加锁-2非阻塞式循环cas操作">实现并发：1.阻塞式，加锁。2.非阻塞式，循环CAS操作。</h3>
<h3 id="1concurrentlinkedqueue">1.ConcurrentLinkedQueue</h3>
<h5 id="简介">简介：</h5>
<p>一个基于链接节点的无界线程安全队列。此队列按照 FIFO（先进先出）原则对元素进行排序。队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。
新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择。此队列不允许使用 null 元素。</p>
<h4 id="常用api">常用API：</h4>
<p>offer( E e) 将元素插入尾部 （类似add）
poll() 取出队头元素并移除队列，如果没有，返回null（类似pop）
peek() 取出队头元素不移除队列.</p>
<h3 id="2concurrenthashmap">2.ConcurrentHashMap</h3>
<h4 id="简介-2">简介：</h4>
<h4 id="jdk18之前">jdk1.8之前：</h4>
<p>ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成，如下图所示
<img src="https://ganxinming.github.io/post-images/1560259573550.png" alt="">
将整个hashmap分成几个小的map，每个segment都是一个锁；与hashtable相比，这么设计的目的是对于put, remove等操作，可以减少并发冲突。
并发控制：是将一个大的table分割成多个小的table来进行加锁，也就是的锁分离技术。
不属于同一个片段的节点可以并发操作，大大提高了性能
本质上Segment类就是一个小的hashmap，里面table数组存储了各个节点的数据，继承了ReentrantLock, 可以作为互拆锁使用。</p>
<h4 id="如果不是segments而是对整个table加锁那么效率低下也就是hashtbalehashtable是对整个表加锁效率低下">如果不是segments，而是对整个table加锁，那么效率低下，也就是hashTbale，Hashtable是对整个表加锁，效率低下。</h4>
<h4 id="jdk18之后">jdk1.8之后：</h4>
<p>改进一：取消segments字段，直接采用transient volatile HashEntry&lt;K,V&gt;[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。jDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作.如下：
<img src="https://ganxinming.github.io/post-images/1560260059020.png" alt="">
改进二：将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。对于hash表来说，最核心的能力在于将key hash之后能均匀的分布在数组中</p>
<h3 id="总结结构采用table数组单向链表红黑树的结构并发控制采用synchronized和cas来操作原来是segments和锁分离技术">总结：结构采用table数组＋单向链表＋红黑树的结构，并发控制采用Synchronized和CAS来操作（原来是：segments，和锁分离技术）</h3>
<h3 id="3concurrentskiplistmap">3.ConcurrentSkipListMap</h3>
<h4 id="特性支持包并发排序-所以插入速度快">特性：支持包并发，排序。（所以插入速度快）</h4>
<p>hashmap是无序的。TreeMap是有序的，底层是根据红黑树来维持排序，相对来说复杂。
而ConcurrentSkipListMap，是基于<strong>跳表</strong>。</p>
<h4 id="跳表">跳表</h4>
<p>是一种随机化的数据结构，通过“空间来换取时间”的一个算法，建立多级索引，实现以二分查找遍历一个有序链表。时间复杂度等同于红黑树，O(log n)。但实现却远远比红黑树要简单。底层结构，可以百度。</p>
<h3 id="4copyonwritelist">4.CopyOnWriteList</h3>
<h4 id="特性支持高并发的list-适合读多写少的操作写时复制">特性：支持高并发的list。适合读多写少的操作（写时复制）</h4>
<p>写：即添加元素时。 在原来的list中，存在安全问题，例如add(e)时，这一瞬间，可能另一个线程读数据，或者读list长度时，会出现脏读的问题。所以要保证线程安全，读的时候需要加锁，且不能加数据。（这是原来的思想）<br>
但是CopyOnWriteList不需要。CopyOnWriteList使用了一种叫写时复制的方法。先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。（整个过程是原子性的，他前后数据一定是一致的，没有中间状态；因为它在新的复制一份的里面做更改，更改完了以后马上把引用指向新的）</p>
<h4 id="有啥好处假如我拿到一份引用根本不需要关心他做过删除还是增加因为这个引用始终是指向完成操作即删除还是增加之后的list">有啥好处？假如我拿到一份引用，根本不需要关心他做过删除还是增加，因为这个引用始终是指向完成操作（即删除还是增加）之后的list。</h4>
<h4 id="适合写少读多">适合写少，读多。</h4>
<h3 id="5blockingqueue">5.BlockingQueue</h3>
<h4 id="特性">特性：</h4>
<p>1.当线程向队列中插入元素时，如果队列已满，则阻塞线程，直到队列有空闲位置（非满）
2.当线程从队列中取元素（删除队列元素）时，如果队列未空，则阻塞线程，直到队列有元素；</p>
<h3 id="api">API :</h3>
<p>offer(E e): 将给定的元素设置到队列中，如果设置成功返回true, 否则返回false. e的值不能为空，否则抛出空指针异常。<br>
offer(E e, long timeout, TimeUnit unit): 将给定元素在给定的时间内设置到队列中，如果设置成功返回true, 否则返回false.<br>
add(E e): 将给定元素设置到队列中，如果设置成功返回true, 否则抛出异常。如果是往限定了长度的队列中设置值，推荐使用offer()方法。<br>
put(E e): 将元素设置到队列中，如果队列中没有多余的空间，该方法会一直阻塞，直到队列中有多余的空间。<br>
take(): 从队列中获取值，如果队列中没有值，线程会一直阻塞，直到队列中有值，并且该方法取得了该值
。<br>
poll(long timeout, TimeUnit unit): 获取并移除此队列的头元素，可以在指定的等待时间前等待可用的元素，timeout表明放弃之前要等待的时间长度，用 unit 的时间单位表示，如果在元素可用前超过了指定的等待时间，则返回null，当等待时可以被中断。</p>
<h4 id="适用于生产者消费者这种情况">适用于生产者，消费者这种情况。</h4>
<h4 id="一般使用四个子类linkedblockingqueuearrayblockingqueuedelayqueuetransferqueue">一般使用四个子类LinkedBlockingQueue，ArrayBlockingQueue，DelayQueue，TransferQueue。</h4>
<p><strong>LinkedBockingQueue</strong>：是链表实现的阻塞式容器，是无界队列（往里扔多少个元素都可以，内存满足的情况下）<br>
<strong>ArrayBlockingQueue</strong>：有界队列（需要指定大小）<br>
<strong>DelayQueue</strong> ：是一个支持延时获取元素的无界阻塞队列。只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的Delayed 元素。<br>
适用场景：定时任务调度（考试后30分钟才能交卷）
<strong>TransferQueue</strong>：提供了transfer方法，一般是这种情形，有一个队列，消费者线程先启动，然后生产者生产一个东西的时候不是往队列里头仍，它首先去找有没有消费者，如果有消费者，生产的东西不往队列里扔了而是直接给消费者消费；如果没有消费者的话，调用transfer线程就会阻塞；<br>
<strong>SynchronousQueue叫做没有容量的队列（TransferQueue一种特殊情况），容量为0，生产者生产的东西必须马上消费掉，如果不消费掉就会出问题；调add抛异常（Queue full），调put程序阻塞；</strong></p>
<h4 id="小结以上五个虽然都不相同但是都是阻塞式即满了阻塞空了等待">小结：以上五个虽然都不相同，但是都是阻塞式，即满了阻塞，空了等待。</h4>
<h2 id="总结">总结：</h2>
<p>对于map/set的选择使用
HashMap       不需要多线程的情况下使用<br>
TreeMap       不需要多线程的情况下使用<br>
LinkedHashMap 不需要多线程的情况下使用</p>
<p>Hashtable     并发量比较小<br>
Collections.sychronizedXXX  并发量比较小</p>
<p>ConcurrentHashMap       高并发<br>
ConcurrentSkipListMap   高并发同时要求排好顺序</p>
<p>2：队列
ArrayList        不需要同步的情况<br>
LinkedList      不需要同步的情况<br>
Collections.synchronizedXXX  并发量低<br>
Vector                            并发量低<br>
CopyOnWriteList              写的时候少，读时候多<br>
Queue<br>
CocurrentLinkedQueue //concurrentArrayQueue    高并发队列
BlockingQueue                                        阻塞式
LinkedBQ    无界
ArrayBQ     有界
TransferQueue   直接给消费者线程，如果没有消费者阻塞
SynchronusQueue  特殊的transferQueue,容量0
DelayQueue执行定时任务</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lambda表达式]]></title>
        <id>https://ganxinming.github.io/post/lambda-biao-da-shi</id>
        <link href="https://ganxinming.github.io/post/lambda-biao-da-shi">
        </link>
        <updated>2019-06-10T12:41:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="lambda简单使用">Lambda简单使用</h3>
<h4 id="1基本语法">1.基本语法</h4>
<p>基本语法:
(parameters) -&gt; expression
或
(parameters) -&gt;{ statements; }</p>
<pre><code>/ 1. 不需要参数,返回值为 5  
() -&gt; 5  
  
// 2. 接收一个参数(数字类型),返回其2倍的值  
x -&gt; 2 * x  
  
// 3. 接受2个参数(数字),并返回他们的差值  
(x, y) -&gt; x – y  
  
// 4. 接收2个int型整数,返回他们的和  
(int x, int y) -&gt; x + y  
  
// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  
(String s) -&gt; System.out.print(s)  
</code></pre>
<h4 id="2遍历list">2.遍历list</h4>
<pre><code>List&lt;String&gt; players =  Arrays.asList(atp);  
  
// 以前的循环方式  
for (String player : players) {  
     System.out.print(player + &quot;; &quot;);  
}  
  
// 使用 lambda 表达式以及函数操作(functional operation)  
players.forEach((player) -&gt; System.out.print(player + &quot;; &quot;));  
   
// 在 Java 8 中使用双冒号操作符(double colon operator)  
players.forEach(System.out::println);  
</code></pre>
<h4 id="3实现线程">3.实现线程</h4>
<pre><code>// 1.1使用匿名内部类  
new Thread(new Runnable() {  
    @Override  
    public void run() {  
        System.out.println(&quot;Hello world !&quot;);  
    }  
}).start();  
  
// 1.2使用 lambda expression  
new Thread(() -&gt; System.out.println(&quot;Hello world !&quot;)).start();  
  
// 2.1使用匿名内部类  
Runnable race1 = new Runnable() {  
    @Override  
    public void run() {  
        System.out.println(&quot;Hello world !&quot;);  
    }  
};  
  
// 2.2使用 lambda expression  
Runnable race2 = () -&gt; System.out.println(&quot;Hello world !&quot;);  
   
// 直接调用 run 方法(没开新线程哦!)  
race1.run();  
race2.run();  
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Synchronized关键字]]></title>
        <id>https://ganxinming.github.io/post/synchronized-guan-jian-zi</id>
        <link href="https://ganxinming.github.io/post/synchronized-guan-jian-zi">
        </link>
        <updated>2019-06-10T02:33:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="synchonized分别不同加锁方法">Synchonized分别不同加锁方法</h2>
<p>1.给某个属性对象加锁。
private Object o=new Object();<br>
sychronized(o){}.<br>
2.给当前对象加锁(锁的是当前对象，当多个线程调用这个类时，使用同一个对象时，只有先获得的先执行)<br>
sychronized(this){}.<br>
3.给方法加锁。（相当于sychronized(this），就是加锁当前对象）
public synchronized  void m(){}<br>
4.给静态方法加锁。（这里等同于T.class，给类对象加锁）
public synchronized static void m() 。<br>
5.给类对象加锁<br>
synchronized(T.class)</p>
<h3 id="记住synchonized只是锁对象"><strong>记住Synchonized只是锁对象</strong></h3>
<p>代码如下</p>
<pre><code>package basis.ThreadTest.simple;

/**
 * @Author Badribbit
 * @create 2019/6/10 10:52
 * @Define Synchronized关键字测试(五种锁对象)
 * @Tutorials
 * @Opinion 1.new Thread(synchronizedTest)和new Thread(new SynchronizedTest())的区别。
 *          锁当前对象或变量对象时对同一个synchronizedTest就有效，但是对每次new SynchronizedTest()无效，因为这些是新new的对象
 *          锁类对象，对new SynchronizedTest()无效。但是得保证里面使用的变量是静态的，如果不是静态的，实际上那些成员变量还是各有各的默认值,
 *          不能达到统一访问的目的。
 *          2.锁静态方法，里面必须是static变量。锁class对象，没有必须，但是想要统一访问，也要使用static变量。
 */
public class SynchronizedTest implements Runnable{
    private  Object o=new Object();
    private  volatile int con=0;
    private  volatile static int sum=0;
    public void m1() throws InterruptedException {
        synchronized (o) {
            System.out.println(Thread.currentThread().getName() + &quot;的con是:&quot; + con++);
            Thread.sleep(100);
        }
    }
    public void m2() throws InterruptedException {
        synchronized (this) {
            System.out.println(Thread.currentThread().getName() + &quot;的con是:&quot; + con++);
            Thread.sleep(100);
        }
    }
    public synchronized void m3() throws InterruptedException {
            System.out.println(Thread.currentThread().getName() + &quot;的con是:&quot; + con++);
            Thread.sleep(100);

    }
    public synchronized static void m4() throws InterruptedException {
        System.out.println(Thread.currentThread().getName() + &quot;的sum是:&quot; + sum++);
        Thread.sleep(100);
    }
    public void m5() throws InterruptedException {
        synchronized (SynchronizedTest.class) {
            System.out.println(Thread.currentThread().getName() + &quot;的sum是:&quot; + sum++);
            Thread.sleep(100);
        }
    }
    @Override
    public void run() {
        try {
            m5();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    public static void main(String[] args) {
        SynchronizedTest synchronizedTest=new SynchronizedTest();
        /*for (int i=0;i&lt;9;i++){
            new Thread(synchronizedTest,String.valueOf((char)(i+97))).start();
        }*/
        for (int i=0;i&lt;9;i++){
            new Thread(new SynchronizedTest(),String.valueOf((char)(i+97))).start();
        }
    }


}

</code></pre>
<h4 id="锁重入">锁重入</h4>
<p>可以在Synchonized中调用其他Synchonized方法。</p>
]]></content>
    </entry>
</feed>