<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Concurrent并发包下的类 | Joke</title>
<link rel="shortcut icon" href="https://ganxinming.github.io/favicon.ico?v=1560326822548">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://ganxinming.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://ganxinming.github.io">
  <img class="avatar" src="https://ganxinming.github.io/images/avatar.png?v=1560326822548" alt="">
  </a>
  <h1 class="site-title">
    Joke
  </h1>
  <p class="site-description">
    那些杀不死你的，必将使你变得更加怪异。
  </p>
  <div class="menu-container">
    
      
        <a href="https://ganxinming.github.io" class="menu">
          首页
        </a>
      
    
      
        <a href="https://ganxinming.github.io/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="https://ganxinming.github.io/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://ganxinming.github.io/post/about/" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

      
        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Concurrent并发包下的类
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-06-11 ·
              </time>
              
                <a href="https://ganxinming.github.io/tag/NvcN0lUBn" class="post-tags">
                  # java多线程
                </a>
              
            </div>
            
            <div class="post-content">
              <h3 id="实现并发1阻塞式加锁-2非阻塞式循环cas操作">实现并发：1.阻塞式，加锁。2.非阻塞式，循环CAS操作。</h3>
<h3 id="1concurrentlinkedqueue">1.ConcurrentLinkedQueue</h3>
<h5 id="简介">简介：</h5>
<p>一个基于链接节点的无界线程安全队列。此队列按照 FIFO（先进先出）原则对元素进行排序。队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。
新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择。此队列不允许使用 null 元素。</p>
<h4 id="常用api">常用API：</h4>
<p>offer( E e) 将元素插入尾部 （类似add）
poll() 取出队头元素并移除队列，如果没有，返回null（类似pop）
peek() 取出队头元素不移除队列.</p>
<h3 id="2concurrenthashmap">2.ConcurrentHashMap</h3>
<h4 id="简介-2">简介：</h4>
<h4 id="jdk18之前">jdk1.8之前：</h4>
<p>ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成，如下图所示
<img src="https://ganxinming.github.io/post-images/1560259573550.png" alt="">
将整个hashmap分成几个小的map，每个segment都是一个锁；与hashtable相比，这么设计的目的是对于put, remove等操作，可以减少并发冲突。
并发控制：是将一个大的table分割成多个小的table来进行加锁，也就是的锁分离技术。
不属于同一个片段的节点可以并发操作，大大提高了性能
本质上Segment类就是一个小的hashmap，里面table数组存储了各个节点的数据，继承了ReentrantLock, 可以作为互拆锁使用。</p>
<h4 id="如果不是segments而是对整个table加锁那么效率低下也就是hashtbalehashtable是对整个表加锁效率低下">如果不是segments，而是对整个table加锁，那么效率低下，也就是hashTbale，Hashtable是对整个表加锁，效率低下。</h4>
<h4 id="jdk18之后">jdk1.8之后：</h4>
<p>改进一：取消segments字段，直接采用transient volatile HashEntry&lt;K,V&gt;[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。jDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作.如下：
<img src="https://ganxinming.github.io/post-images/1560260059020.png" alt="">
改进二：将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。对于hash表来说，最核心的能力在于将key hash之后能均匀的分布在数组中</p>
<h3 id="总结结构采用table数组单向链表红黑树的结构并发控制采用synchronized和cas来操作原来是segments和锁分离技术">总结：结构采用table数组＋单向链表＋红黑树的结构，并发控制采用Synchronized和CAS来操作（原来是：segments，和锁分离技术）</h3>
<h3 id="3concurrentskiplistmap">3.ConcurrentSkipListMap</h3>
<h4 id="特性支持包并发排序-所以插入速度快">特性：支持包并发，排序。（所以插入速度快）</h4>
<p>hashmap是无序的。TreeMap是有序的，底层是根据红黑树来维持排序，相对来说复杂。
而ConcurrentSkipListMap，是基于<strong>跳表</strong>。</p>
<h4 id="跳表">跳表</h4>
<p>是一种随机化的数据结构，通过“空间来换取时间”的一个算法，建立多级索引，实现以二分查找遍历一个有序链表。时间复杂度等同于红黑树，O(log n)。但实现却远远比红黑树要简单。底层结构，可以百度。</p>
<h3 id="4copyonwritelist">4.CopyOnWriteList</h3>
<h4 id="特性支持高并发的list-适合读多写少的操作写时复制">特性：支持高并发的list。适合读多写少的操作（写时复制）</h4>
<p>写：即添加元素时。 在原来的list中，存在安全问题，例如add(e)时，这一瞬间，可能另一个线程读数据，或者读list长度时，会出现脏读的问题。所以要保证线程安全，读的时候需要加锁，且不能加数据。（这是原来的思想）<br>
但是CopyOnWriteList不需要。CopyOnWriteList使用了一种叫写时复制的方法。先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。（整个过程是原子性的，他前后数据一定是一致的，没有中间状态；因为它在新的复制一份的里面做更改，更改完了以后马上把引用指向新的）</p>
<h4 id="有啥好处假如我拿到一份引用根本不需要关心他做过删除还是增加因为这个引用始终是指向完成操作即删除还是增加之后的list">有啥好处？假如我拿到一份引用，根本不需要关心他做过删除还是增加，因为这个引用始终是指向完成操作（即删除还是增加）之后的list。</h4>
<h4 id="适合写少读多">适合写少，读多。</h4>
<h3 id="5blockingqueue">5.BlockingQueue</h3>
<h4 id="特性">特性：</h4>
<p>1.当线程向队列中插入元素时，如果队列已满，则阻塞线程，直到队列有空闲位置（非满）
2.当线程从队列中取元素（删除队列元素）时，如果队列未空，则阻塞线程，直到队列有元素；</p>
<h3 id="api">API :</h3>
<p>offer(E e): 将给定的元素设置到队列中，如果设置成功返回true, 否则返回false. e的值不能为空，否则抛出空指针异常。<br>
offer(E e, long timeout, TimeUnit unit): 将给定元素在给定的时间内设置到队列中，如果设置成功返回true, 否则返回false.<br>
add(E e): 将给定元素设置到队列中，如果设置成功返回true, 否则抛出异常。如果是往限定了长度的队列中设置值，推荐使用offer()方法。<br>
put(E e): 将元素设置到队列中，如果队列中没有多余的空间，该方法会一直阻塞，直到队列中有多余的空间。<br>
take(): 从队列中获取值，如果队列中没有值，线程会一直阻塞，直到队列中有值，并且该方法取得了该值
。<br>
poll(long timeout, TimeUnit unit): 获取并移除此队列的头元素，可以在指定的等待时间前等待可用的元素，timeout表明放弃之前要等待的时间长度，用 unit 的时间单位表示，如果在元素可用前超过了指定的等待时间，则返回null，当等待时可以被中断。</p>
<h4 id="适用于生产者消费者这种情况">适用于生产者，消费者这种情况。</h4>
<h4 id="一般使用四个子类linkedblockingqueuearrayblockingqueuedelayqueuetransferqueue">一般使用四个子类LinkedBlockingQueue，ArrayBlockingQueue，DelayQueue，TransferQueue。</h4>
<p><strong>LinkedBockingQueue</strong>：是链表实现的阻塞式容器，是无界队列（往里扔多少个元素都可以，内存满足的情况下）<br>
<strong>ArrayBlockingQueue</strong>：有界队列（需要指定大小）<br>
<strong>DelayQueue</strong> ：是一个支持延时获取元素的无界阻塞队列。只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的Delayed 元素。<br>
适用场景：定时任务调度（考试后30分钟才能交卷）
<strong>TransferQueue</strong>：提供了transfer方法，一般是这种情形，有一个队列，消费者线程先启动，然后生产者生产一个东西的时候不是往队列里头仍，它首先去找有没有消费者，如果有消费者，生产的东西不往队列里扔了而是直接给消费者消费；如果没有消费者的话，调用transfer线程就会阻塞；<br>
<strong>SynchronousQueue叫做没有容量的队列（TransferQueue一种特殊情况），容量为0，生产者生产的东西必须马上消费掉，如果不消费掉就会出问题；调add抛异常（Queue full），调put程序阻塞；</strong></p>
<h4 id="小结以上五个虽然都不相同但是都是阻塞式即满了阻塞空了等待">小结：以上五个虽然都不相同，但是都是阻塞式，即满了阻塞，空了等待。</h4>
<h2 id="总结">总结：</h2>
<p>对于map/set的选择使用
HashMap       不需要多线程的情况下使用<br>
TreeMap       不需要多线程的情况下使用<br>
LinkedHashMap 不需要多线程的情况下使用</p>
<p>Hashtable     并发量比较小<br>
Collections.sychronizedXXX  并发量比较小</p>
<p>ConcurrentHashMap       高并发<br>
ConcurrentSkipListMap   高并发同时要求排好顺序</p>
<p>2：队列
ArrayList        不需要同步的情况<br>
LinkedList      不需要同步的情况<br>
Collections.synchronizedXXX  并发量低<br>
Vector                            并发量低<br>
CopyOnWriteList              写的时候少，读时候多<br>
Queue<br>
CocurrentLinkedQueue //concurrentArrayQueue    高并发队列
BlockingQueue                                        阻塞式
LinkedBQ    无界
ArrayBQ     有界
TransferQueue   直接给消费者线程，如果没有消费者阻塞
SynchronusQueue  特殊的transferQueue,容量0
DelayQueue执行定时任务</p>

            </div>
          </article>
        </div>
    
        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://ganxinming.github.io/post/lambda-biao-da-shi">
              <h3 class="post-title">
                Lambda表达式
              </h3>
            </a>
          </div>  
        

        
    
        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://ganxinming.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
